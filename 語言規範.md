# Glux 語言設計規範

Glux 是一門 **簡單、高效、省記憶體、支援併發、可編譯為二進制** 的靜態類型語言，擁有直覺的語法，結合了 Python、Go、Rust 的優勢。

---

## 1. 語法規範

### 1.1 變數與常數
- 變數使用 `:=` 進行宣告，類似 Go 的簡潔語法，支援型別推導。
- 常數使用 `const`，允許在編譯時或執行時決定數值。
- **支援連續比較運算**（如 `0 < x < 8`），語意等同於 `0 < x && x < 8`。

#### 範例
```rust
x := 10         // int，自動推導
y := 3.14       // float，自動推導
name := "Alice" // string
const PI = 3.1415  // 常數
```

---

### 1.2 型別系統
- **自動調整數值型別**，避免 Go 需要手動轉換 `int64(x)`。
- **集合型別支援異質性**，不需 `interface{}`。
- **內建 `string()` 可轉換任何型別為字串**。

#### 範例
```rust
x := 10         // int8
y := 30000      // 自動變成 int16
z := 2_000_000_000  // 自動變成 int32

data := [10, "hi", 3.14] // list<any>
println(string(data))  // "[10, hi, 3.14]"
```

附上型別系統的總結表：

| 分類 | 型別 | 關鍵字 |
|------|------|------|
| **基本型別** | 整數 | `int`（自動調整大小） |
|  | 浮點數 | `float`（自動調整大小） |
|  | 布林值 | `bool` |
|  | 字串 | `string` |
|  | 任意型別 | `any` |
| **集合型別** | 元組 | `tuple` |
|  | 清單 | `list` |
|  | 陣列 | `array` |
|  | 映射 | `map` |
| **函式型別** | 函式 | `fn<T>` |
| **進階型別** | 多選型別 | `union<T1, T2>` |
|  | 指標 | `ptr<T>` |
|  | 選用型別 | `optional<T>` |

---

### 1.3 控制流程
- `if`、`while` 條件表達式無需括號 `()`。
- **支援連續比較運算**（如 `0 < x < 8`），提高可讀性。
- `for` 使用 `range()` 迭代，不支援傳統 `for (init; condition; update)`。

#### 範例
```rust
if 0 < x < 8 {
    println("x 在範圍內")
}

while x < 100 {
    x *= 2
}

for i in range(5) {
    println(i)  // 0, 1, 2, 3, 4
}

for key, value in {"a": 1, "b": 2} {
    println(`${key}: ${value}`)
}
```

---

## 2. 運算符

✅ **`and`、`or`、`not` 可用關鍵字或符號**  
✅ **比 Go 更靈活（Go 只有 `&&`、`||`、`!`）**

#### 範例
```rust
if x > 0 and y < 10 {
    print("範圍內")
}

if x > 0 && y < 10 {
    print("範圍內")
}

flag := not x
flag2 := !x
```

---

## 3. 標準函式

### 3.1 `print()` 與 `println()`
- **`print()`**：輸出字串但不換行。
- **`println()`**：輸出字串並自動換行。
- **支援 `${}` 字串插值**，比 Go `fmt.Sprintf()` 更簡潔。
- **使用 \`（反引號）支援插值**，使用 `"` 會當作純字串處理。

#### 範例
```rust
name := "Alice"
age := 25
print(`Hello, ${name}. You are ${age} years old.`)  // 不換行
println(` 你的年齡是 ${age}.`)  // 換行輸出

nums := [1, 2, 3]
println("List:", nums)  // 自動轉換 "[1, 2, 3]"
```

---

## 4. 可見性

✅ **首字母大寫公開，小寫私有**（與 Go 相同，避免 `public` / `private` 關鍵字）

#### 範例
```rust
struct User {
    Name: string  // 公開
    age: int      // 私有
}
```

---

## 5. 函式與閉包
Glux 支援 **函式（Function）**、**匿名函式（Lambda）** 以及 **閉包（Closure）**，並提供靜態語言的高效與靈活性，使函式成為 **一級公民（First-Class Citizen）**。

### 5.1 基本函式語法
- **函式使用 `fn` 宣告**，回傳型別使用 `->` 指定。
- **可選回傳型別**，若省略則根據 `return` 自動推導。
- **支援預設參數**，允許部分參數有預設值。
- **函式可作為變數、參數與回傳值**。

#### 範例
```rust
fn add(x: int, y: int) -> int {
    return x + y
}

println(add(2, 3))  // 5
```

---

### 5.2 匿名函式（Lambda）
Glux 支援 **匿名函式**，但不使用箭頭函式，而是採用標準函式語法：
- **使用 `fn` 宣告匿名函式**，並可直接賦值給變數。
- **可作為參數傳遞至其他函式**。

#### 範例
```rust
double := fn(x: int) -> int {
    return x * 2
}

println(double(10))  // 20
```

**作為參數傳遞**
```rust
fn apply_twice(f: fn(int) -> int, x: int) -> int {
    return f(f(x))
}

println(apply_twice(fn(x: int) -> int {
    return x + 3
}, 5))  // (5+3) + 3 = 11
```

---

### 5.3 閉包（Closure）
- **函式可捕獲外部變數**，形成 **閉包**。
- **變數可讀取與修改**，與 Rust 類似。

#### 範例
```rust
fn make_multiplier(factor: int) -> fn(int) -> int {
    return fn(x: int) -> int {
        return x * factor
    }
}

double := make_multiplier(2)
triple := make_multiplier(3)

println(double(5))  // 10
println(triple(5))  // 15
```

---

### 5.4 函式作為回傳值
函式可以作為 **回傳值**，允許動態生成新函式。

#### 範例
```rust
fn choose_operation(op: string) -> fn(int, int) -> int {
    if op == "add" {
        return fn(a: int, b: int) -> int {
            return a + b
        }
    } else {
        return fn(a: int, b: int) -> int {
            return a - b
        }
    }
}

op := choose_operation("add")
println(op(3, 5))  // 8
```

---

### 5.5 變數捕獲（Capturing）
- **閉包可讀取與修改外部變數**。
- **如果閉包在函式返回後仍存活，則變數會存於堆區（Heap）**。

#### 範例
```rust
fn counter() -> fn() -> int {
    count := 0
    return fn() -> int {
        count += 1
        return count
    }
}

next := counter()
println(next())  // 1
println(next())  // 2
```

---

### 5.6 高階函式（Higher-Order Function）
Glux **支援函式作為參數**，允許更簡潔的高階函式（HOF）。

#### 範例
```rust
fn map(lst: list<int>, f: fn(int) -> int) -> list<int> {
    result := []
    for x in lst {
        result.append(f(x))
    }
    return result
}

println(map([1, 2, 3, 4], fn(x: int) -> int {
    return x * x
}))  // [1, 4, 9, 16]
```

---

## 6. 併發機制
- 使用 `spawn fn` 啟動輕量執行緒，類似 Goroutine。
- 併發任務不會隱式等待，需使用 `await` 顯式同步。
- `await` 可同時等待多個任務，類似 `Promise.all()`。

#### 範例
```rust
spawn fn work1() {
    println("工作 1 開始")
    sleep(1)
    println("工作 1 結束")
}

spawn fn work2() {
    println("工作 2 開始")
    sleep(2)
    println("工作 2 結束")
}

await work1(), work2()  // 等待最慢的完成
println("所有工作結束")
```

---

## 7. `await` 回傳值規範
### 7.1 單一 `await`
當 `await` 用於單一函式時，會等待其執行完成，並回傳該函式的結果。

#### 範例
```rust
spawn fn get_data() -> int {
    sleep(1)
    return 42
}

result := await get_data()
println(`結果: ${result}`)  // "結果: 42"
```

---

### 7.2 `await` 多個函式
當 `await` 用於 **多個函式** 時，回傳 **tuple**，且結果順序與函式順序相同。

#### 範例
```rust
spawn fn task1() -> string {
    sleep(1)
    return "A"
}

spawn fn task2() -> string {
    sleep(2)
    return "B"
}

results := await task1(), task2()
println(`結果: ${results}`)  // "結果: ("A", "B")"
```

---

### 7.3 `await` 內建錯誤處理
若 `await` 內的某個函式發生錯誤：
- **預設行為**：回傳 `error<T>` 類型（類似 Rust `Result<T, E>`）。
- **可選行為**：使用 `try` 來捕獲錯誤。

#### 範例
```rust
spawn fn fail_task() -> int {
    sleep(1)
    return error("任務失敗")
}

result := await fail_task()
if result is error {
    println(`錯誤: ${result}`)
} else {
    println(`成功: ${result}`)
}
```

---

### 7.4 `await` 用於迴圈
當有 **多個併發函式** 需要逐一處理時，可用 `for` 迭代 `await` 結果：

#### 範例
```rust
tasks := [task1(), task2(), task3()]

for result in await tasks {
    println(`結果: ${result}`)
}
```
**行為解析**：
- `await tasks` 會 **同時等待所有函式** 執行完畢。
- `for result in await tasks` **逐一處理結果**。

---
