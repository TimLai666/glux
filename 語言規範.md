# Glux 語言設計規範

Glux 是一門 **簡單、高效、省記憶體、支援併發、可編譯為二進制** 的靜態類型語言，擁有直覺的語法，結合了 Python、Go、Rust 的優勢。

---

## 1. 語法規範

### 1.1 變數與常數
- 變數使用 `:=` 進行宣告，類似 Go 的簡潔語法，支援型別推導。
- 常數使用 `const`，允許在編譯時或執行時決定數值。
- **支援連續比較運算**（如 `0 < x < 8`），語意等同於 `0 < x && x < 8`。

#### 範例
```rust
x := 10         // 自動推導為 int，根據數值大小選擇能容納該數值的最小型別
y := 3.14       // 自動推導為 float，同樣選擇最小精度型別
name := "Alice" // string
const PI = 3.1415  // 常數
```

---

### 1.2 型別系統

- **自動調整數值型別**  
  Glux 會根據整數或浮點數的數值範圍，自動選擇**能容納該數值的最小型別**。  
  預設範圍如下：
  
  #### 整數 (int)
  - **int8**：範圍 -128 ~ 127  
    例：`x := 10`（若數值落在 int8 範圍內）
  - **int16**：範圍 -32,768 ~ 32,767  
    例：`y := 30000`（自動推導為 int16）
  - **int32**：範圍 -2,147,483,648 ~ 2,147,483,647  
    例：`z := 2_000_000_000`（自動推導為 int32）
  - **int64**：範圍 -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807  
    若數值超出 int32 範圍，且在 int64 內則自動推導為 int64。
  
  #### 浮點數 (float)
  - **float32**：32 位 IEEE 754 浮點數，精度約 7 位有效數字  
    當數值適中且精度要求不高時，採用 float32。
  - **float64**：64 位 IEEE 754 浮點數，精度約 15 位有效數字  
    當數值較大或需要更高精度時，自動推導為 float64。
  
- **集合型別支援異質性**，不需使用類似 Go 的 `interface{}`。
- **內建函式 `string()`** 可轉換任何型別為字串（此為內置函式之一，與 `sleep()`、`len()` 同級）。

#### 範例
```rust
x := 10         // 推導為 int8 (若數值符合 int8 範圍)
y := 30000      // 推導為 int16
z := 2_000_000_000  // 推導為 int32
bigNum := 10_000_000_000  // 超出 int32，自動推導為 int64

pi32 := 3.14    // 推導為 float32
largeFloat := 3.141592653589793  // 推導為 float64
```

附上型別系統的總結表：

| 分類       | 型別       | 關鍵字/說明                                     |
|------------|------------|------------------------------------------------|
| **基本型別** | 整數       | `int`（自動調整至 int8、int16、int32、int64；預設使用最小型別）   |
|            | 浮點數     | `float`（自動調整至 float32 或 float64；預設使用最小型別）         |
|            | 布林值     | `bool`                                         |
|            | 字串       | `string`                                       |
|            | 任意型別   | `any`                                          |
| **集合型別** | 元組       | `tuple`                                        |
|            | 清單       | `list`                                         |
|            | 陣列       | `array`                                        |
|            | 映射       | `map`                                          |
| **函式型別** | 函式       | `fn<T>`                                        |
| **進階型別** | 多選型別   | `union<T1, T2>`                                |
|            | 指標       | `ptr<T>`                                       |
|            | 選用型別   | `optional<T>`                                  |

---

### 1.3 控制流程
- `if`、`while` 條件表達式無需括號 `()`。
- **支援連續比較運算**（如 `0 < x < 8`），提高可讀性。
- `for` 使用 `range()` 迭代，不支援傳統 `for (init; condition; update)`。

#### 範例
```rust
if 0 < x < 8 {
    println("x 在範圍內")
}

while x < 100 {
    x *= 2
}

for i in range(5) {
    println(i)  // 輸出 0, 1, 2, 3, 4
}

for key, value in {"a": 1, "b": 2} {
    println(`${key}: ${value}`)
}
```

---

## 2. 運算符

✅ **`and`、`or`、`not` 可用關鍵字或符號**  
✅ **比 Go 更靈活（Go 只有 `&&`、`||`、`!`）**

#### 範例
```rust
if x > 0 and y < 10 {
    print("範圍內")
}

if x > 0 && y < 10 {
    print("範圍內")
}

flag := not x
flag2 := !x
```

---

## 3. 標準函式

### 3.1 內置函式
內置函式包含常用的工具，例如：
- **string()**：將任何型別轉換為字串，方便輸出與除錯。
- **sleep()**：暫停執行，用於併發與計時操作。
- **len()**：計算集合型別（如 list、array、map、tuple）或字串的長度。

### 3.2 `print()` 與 `println()`
- **`print()`**：輸出字串但不換行。
- **`println()`**：輸出字串並自動換行。
- **支援 `${}` 字串插值**，比 Go 的 `fmt.Sprintf()` 更簡潔。
- **使用 \`（反引號）支援插值**，使用 `"` 會當作純字串處理。

#### 範例
```rust
name := "Alice"
age := 25
print(`Hello, ${name}. You are ${age} years old.`)  // 不換行
println(`你的年齡是 ${age}.`)  // 換行輸出

nums := [1, 2, 3]
println("List:", nums)  // 自動轉換為 "[1, 2, 3]"
```

#### 3.3 字串處理
- **字串串接**：支援使用 `+` 運算子串接多個字串。  
  **範例：**
  ```rust
  greeting := "Hello, " + "World!"
  println(greeting)  // 輸出 "Hello, World!"
  ```
- **多行字串**：使用反引號 `` ` `` 定義多行字串，保留換行與空白。  
  **範例：**
  ```rust
  poem := `這是一首詩，
  可以跨多行，
  每行的空白都會被保留。`
  println(poem)
  ```

---

## 4. 可見性

✅ **首字母大寫公開，小寫私有**（與 Go 相同，避免 `public` / `private` 關鍵字）

#### 範例
```rust
struct User {
    Name: string  // 公開
    age: int      // 私有
}
```

---

## 5. 函式與閉包
Glux 支援 **函式（Function）**、**匿名函式（Lambda）** 以及 **閉包（Closure）**，並提供靜態語言的高效與靈活性，使函式成為 **一級公民（First-Class Citizen）**。

### 5.1 基本函式語法
- **函式使用 `fn` 宣告**，回傳型別使用 `->` 指定。
- **可選回傳型別**，若省略則根據 `return` 自動推導。
- **支援預設參數**，允許部分參數有預設值。
- **函式可作為變數、參數與回傳值**。

#### 範例
```rust
fn add(x: int, y: int) -> int {
    return x + y
}

println(add(2, 3))  // 輸出 5
```

---

### 5.2 匿名函式（Lambda）
Glux 支援 **匿名函式**，但不使用箭頭函式，而是採用標準函式語法：
- **使用 `fn` 宣告匿名函式**，並可直接賦值給變數。
- **可作為參數傳遞至其他函式**。

#### 範例
```rust
double := fn(x: int) -> int {
    return x * 2
}

println(double(10))  // 輸出 20
```

**作為參數傳遞**
```rust
fn apply_twice(f: fn(int) -> int, x: int) -> int {
    return f(f(x))
}

println(apply_twice(fn(x: int) -> int {
    return x + 3
}, 5))  // 輸出 11 ((5+3)+3)
```

---

### 5.3 閉包（Closure）
- **函式可捕獲外部變數**，形成 **閉包**。
- **變數可讀取與修改**，與 Rust 類似。

#### 範例
```rust
fn make_multiplier(factor: int) -> fn(int) -> int {
    return fn(x: int) -> int {
        return x * factor
    }
}

double := make_multiplier(2)
triple := make_multiplier(3)

println(double(5))  // 輸出 10
println(triple(5))  // 輸出 15
```

---

### 5.4 函式作為回傳值
函式可以作為 **回傳值**，允許動態生成新函式。

#### 範例
```rust
fn choose_operation(op: string) -> fn(int, int) -> int {
    if op == "add" {
        return fn(a: int, b: int) -> int {
            return a + b
        }
    } else {
        return fn(a: int, b: int) -> int {
            return a - b
        }
    }
}

op := choose_operation("add")
println(op(3, 5))  // 輸出 8
```

---

### 5.5 變數捕獲（Capturing）
- **閉包可讀取與修改外部變數**。
- **若閉包在函式返回後仍存活，則變數將存於堆區（Heap）**。

#### 範例
```rust
fn counter() -> fn() -> int {
    count := 0
    return fn() -> int {
        count += 1
        return count
    }
}

next := counter()
println(next())  // 輸出 1
println(next())  // 輸出 2
```

---

### 5.6 高階函式（Higher-Order Function）
Glux **支援函式作為參數**，允許更簡潔的高階函式（HOF）。

#### 範例
```rust
fn map(lst: list<int>, f: fn(int) -> int) -> list<int> {
    result := []
    for x in lst {
        result.append(f(x))
    }
    return result
}

println(map([1, 2, 3, 4], fn(x: int) -> int {
    return x * x
}))  // 輸出 [1, 4, 9, 16]
```

---

## 6. 併發機制
- 使用 `spawn fn` 啟動輕量執行緒，類似 Goroutine。
- 併發任務不會隱式等待，需使用 `await` 顯式同步。
- `await` 可同時等待多個任務，類似 `Promise.all()`。

#### 範例
```rust
spawn fn work1() {
    println("工作 1 開始")
    sleep(1)
    println("工作 1 結束")
}

spawn fn work2() {
    println("工作 2 開始")
    sleep(2)
    println("工作 2 結束")
}

await work1(), work2()  // 等待最慢的任務完成
println("所有工作結束")
```

---

## 7. `await` 回傳值規範
### 7.1 單一 `await`
當 `await` 用於單一函式時，會等待其執行完成，並回傳該函式的結果。

#### 範例
```rust
spawn fn get_data() -> int {
    sleep(1)
    return 42
}

result := await get_data()
println(`結果: ${result}`)  // 輸出 "結果: 42"
```

---

### 7.2 `await` 多個函式
當 `await` 用於 **多個函式** 時，回傳 **tuple**，且結果順序與函式順序相同。

#### 範例
```rust
spawn fn task1() -> string {
    sleep(1)
    return "A"
}

spawn fn task2() -> string {
    sleep(2)
    return "B"
}

results := await task1(), task2()
println(`結果: ${results}`)  // 輸出 "結果: ("A", "B")"
```

---

### 7.3 `await` 內建錯誤處理
若 `await` 中的某個函式發生錯誤：
- **預設行為**：回傳 `error<T>` 類型（類似 Rust 的 `Result<T, E>`）。
- **可選行為**：可使用 `try` 捕獲錯誤。

#### 範例
```rust
spawn fn fail_task() -> int {
    sleep(1)
    return error("任務失敗")
}

result := await fail_task()
if result is error {
    println(`錯誤: ${result}`)
} else {
    println(`成功: ${result}`)
}
```

---

### 7.4 `await` 用於迴圈
當有 **多個併發函式** 需要逐一處理時，可使用 `for` 迭代 `await` 結果：

#### 範例
```rust
tasks := [task1(), task2(), task3()]

for result in await tasks {
    println(`結果: ${result}`)
}
```
**行為解析**：
- `await tasks` 會 **同時等待所有函式** 執行完畢。
- `for result in await tasks` **逐一處理每個結果**。
