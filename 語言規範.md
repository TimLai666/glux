# Glux 語言設計規範

Glux 是一門 **簡單、高效、省記憶體、支援併發、可編譯為二進制** 的靜態類型語言，擁有直覺的語法，結合了 Python、Go、Rust 的優勢。

---

## 1. 語法規範

### 1.1 變數與常數
- 變數使用 `:=` 進行宣告，類似 Go 的簡潔語法，支援型別推導。
- 常數使用 `const`，允許在編譯時或執行時決定數值。
- **支援連續比較運算**（如 `0 < x < 8`），語意等同於 `0 < x && x < 8`。

#### 範例
```rust
x := 10         // 自動推導為 int，根據數值大小選擇能容納該數值的最小型別
y := 3.14       // 自動推導為 float，同樣選擇最小精度型別
name := "Alice" // string
const PI = 3.1415  // 常數
```

---

### 1.2 型別系統

- **自動調整數值型別**  
  Glux 會根據整數或浮點數的數值範圍，自動選擇**能容納該數值的最小型別**。
  
  #### 整數 (int)
  - **int8**：範圍 -128 ~ 127  
    例：`x := 10`（若數值落在 int8 範圍內）
  - **int16**：範圍 -32,768 ~ 32,767  
    例：`y := 30000`（自動推導為 int16）
  - **int32**：範圍 -2,147,483,648 ~ 2,147,483,647  
    例：`z := 2_000_000_000`（自動推導為 int32）
  - **int64**：範圍 -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807  
    若數值超出 int32 範圍且在 int64 內，則自動推導為 int64.
  
  #### 浮點數 (float)
  - **float32**：32 位 IEEE 754 浮點數，精度約 7 位有效數字  
    當數值適中且精度要求不高時，採用 float32.
  - **float64**：64 位 IEEE 754 浮點數，精度約 15 位有效數字  
    當數值較大或需要更高精度時，自動推導為 float64.
  
- **內置錯誤型別 error**  
  Glux 內置錯誤型別 **error**，用於表示錯誤狀態與錯誤訊息，通常與 union 搭配使用實現錯誤處理。

- **集合型別支援異質性**  
  集合型別（如 tuple、list、array、map）不需要指定內部元素型別，允許同時存放不同型別的值。例如：
  ```rust
  mixedList := [10, "hello", 3.14]  // list 可包含不同型別
  ```
- **內建函式 `string()`**  
  可轉換任何型別為字串（此為內置函式之一，與 `sleep()`、`len()` 同級）。

#### 範例
```rust
x := 10         // 推導為 int8 (若數值符合 int8 範圍)
y := 30000      // 推導為 int16
z := 2_000_000_000  // 推導為 int32
bigNum := 10_000_000_000  // 超出 int32，自動推導為 int64

pi32 := 3.14    // 推導為 float32
largeFloat := 3.141592653589793  // 推導為 float64
```

附上型別系統的總結表：

| 分類         | 型別         | 說明                                                     |
|--------------|--------------|----------------------------------------------------------|
| **基本型別**   | 整數         | `int`（自動調整至 int8、int16、int32、int64；預設使用最小型別）       |
|              | 浮點數       | `float`（自動調整至 float32 或 float64；預設使用最小型別）             |
|              | 布林值       | `bool`                                                 |
|              | 字串         | `string`                                               |
|              | 任意型別     | `any`                                                  |
|              | 錯誤         | `error`（內置錯誤型別，用於表示錯誤狀態與訊息）                     |
| **集合型別**   | 元組         | `tuple`（值不能更改）                                   |
|              | 清單         | `list`                                                 |
|              | 陣列         | `array`                                                |
|              | 映射         | `map`                                                  |
| **函式型別**   | 函式         | `fn<T>`                                                |
| **進階型別**   | 多選型別     | `union<T1, T2>`                                        |
|              | 指標         | `ptr<T>`                                               |
|              | 選用型別     | `optional<T>`                                          |

---

### 1.3 控制流程
- `if`、`while` 條件表達式無需括號 `()`。
- **支援連續比較運算**（如 `0 < x < 8`），提高可讀性。
- `for` 使用 `range()` 迭代，不支援傳統 `for (init; condition; update)`。

#### 範例
```rust
if 0 < x < 8 {
    println("x 在範圍內")
}

while x < 100 {
    x *= 2
}

for i in range(5) {
    println(i)  // 輸出 0, 1, 2, 3, 4
}

for key, value in {"a": 1, "b": 2} {
    println(`${key}: ${value}`)
}
```

---

## 2. 運算符定義

### 算術運算符
- **`+`**  
  - 執行加法運算或字串串接。
  - 例如：
    ```rust
    a := 10 + 20        // 結果 30
    greeting := "Hello, " + "World!"  // 輸出 "Hello, World!"
    ```
- **`-`**  
  - 執行減法運算。
  - 例如：
    ```rust
    diff := 20 - 5       // 結果 15
    ```
- **`*`**  
  - 執行乘法運算。
  - 例如：
    ```rust
    product := 5 * 3     // 結果 15
    ```
- **`/`**  
  - 執行除法運算（整數或浮點數）。
  - 例如：
    ```rust
    quotient := 20 / 4   // 結果 5
    ```
- **`%`**  
  - 計算除法餘數。
  - 例如：
    ```rust
    remainder := 20 % 3  // 結果 2
    ```

### 比較運算符
- **`==`**、**`!=`**、**`<`**、**`<=`**、**`>`**、**`>=`**  
  - 用於檢查相等與大小比較。

### 邏輯運算符
- **`and`** 或 **`&&`**  
  - 邏輯與。
- **`or`** 或 **`||`**  
  - 邏輯或。
- **`not`** 或 **`!`**  
  - 邏輯非。

### 位元運算符
- **`&`**、**`|`**、**`^`**、**`~`**  
  - 分別用於位元與、位元或、位元異或、位元取反。  
  - 注意：當作取地址運算符時，`&` 用於取得變數指標。

### 位移運算符
- **`<<`**、**`>>`**  
  - 分別用於左移與右移。  
  - 注意：對指標或低階資料進行位移運算必須在 `unsafe { }` 區塊中執行。

### 賦值運算符
- **`:=`**  
  - 用於宣告並初始化變數。
- **`=`**  
  - 用於對已宣告變數賦值（若語言規範允許）。
- **複合賦值運算符**  
  如 **`+=`**、**`-=`**、**`*=`**、**`/=`**、**`%=`** 等。

### 其他運算符
- **`.`**（點運算子）  
  - 用於存取結構體或其他複合型別的成員。若該成員為指標，Glux 會自動解參考。
- **`,`**（逗號）  
  - 用於分隔函式參數、tuple 成員等。

---

## 3. 標準函式

### 3.1 內置函式
內置函式包含常用工具，例如：
- **string()**：轉換任何型別為字串。
- **sleep()**：暫停執行，適用於併發與計時操作。
- **len()**：計算集合（如 list、array、map、tuple）或字串長度。
- **copy()**：對集合、結構體或其他複合型別進行深拷貝，返回一個與原物件不共享記憶體的新物件。
- **error()**：生成一個 error 型別的錯誤物件，通常接受一個錯誤訊息字串作為參數。
- **int()**、**float()**、**bool()**：強制將其他型別轉換為 int、float 或 bool。

### 3.2 `print()` 與 `println()`
- **`print()`**：輸出字串但不換行。
- **`println()`**：輸出字串並自動換行。
- 支援 `${}` 字串插值；使用反引號（`）進行插值處理。

#### 範例
```rust
name := "Alice"
age := 25
print(`Hello, ${name}. You are ${age} years old.`)
println(`你的年齡是 ${age}.`)
nums := [1, 2, 3]
println("List:", nums)
```

#### 3.3 字串處理
- **字串串接**：使用 `+` 運算子串接字串。
  ```rust
  greeting := "Hello, " + "World!"
  println(greeting)  // 輸出 "Hello, World!"
  ```
- **多行字串**：使用反引號定義多行字串，保留換行與空白。
  ```rust
  poem := `這是一首詩，
  可以跨多行，
  每行的空白都會被保留。`
  println(poem)
  ```

---

## 4. 可見性

- **首字母大寫公開，小寫私有**，與 Go 規範一致，不使用 `public` 或 `private` 關鍵字。

#### 範例
```rust
struct User {
    Name: string,  // 公開
    age: int,      // 私有
}
```

---

## 5. 函式與閉包

### 5.1 基本函式語法
- 使用 `fn` 宣告函式，回傳型別使用 `->` 指定。
- 可選回傳型別，若省略則根據 `return` 自動推導。
- 支援預設參數。
- 函式可作為變數、參數與回傳值。

#### 範例
```rust
fn add(x: int, y: int) -> int {
    return x + y
}
println(add(2, 3))
```

### 5.2 匿名函式（Lambda）
- 使用 `fn` 宣告匿名函式，可直接賦值給變數，並作為參數傳遞。

#### 範例
```rust
double := fn(x: int) -> int { return x * 2 }
println(double(10))
fn apply_twice(f: fn(int) -> int, x: int) -> int { return f(f(x)) }
println(apply_twice(fn(x: int) -> int { return x + 3 }, 5))
```

### 5.3 閉包（Closure）
- 閉包可捕獲外部變數，並允許讀取與修改（類似 Rust）。

#### 範例
```rust
fn make_multiplier(factor: int) -> fn(int) -> int {
    return fn(x: int) -> int { return x * factor }
}
double := make_multiplier(2)
triple := make_multiplier(3)
println(double(5))
println(triple(5))
```

### 5.4 函式作為回傳值
- 函式可作為回傳值，允許動態生成函式。

#### 範例
```rust
fn choose_operation(op: string) -> fn(int, int) -> int {
    if op == "add" { return fn(a: int, b: int) -> int { return a + b } }
    else { return fn(a: int, b: int) -> int { return a - b } }
}
op := choose_operation("add")
println(op(3, 5))
```

### 5.5 變數捕獲（Capturing）
- 閉包可捕獲並修改外部變數；若閉包超出函式作用域，捕獲變數將存於堆區。

#### 範例
```rust
fn counter() -> fn() -> int {
    count := 0
    return fn() -> int { count += 1; return count }
}
next := counter()
println(next())
println(next())
```

### 5.6 高階函式（Higher-Order Function）
- 支援函式作為參數傳入。

#### 範例
```rust
fn map(lst: list, f: fn(int) -> int) -> list {
    result := []
    for x in lst { result.append(f(x)) }
    return result
}
println(map([1, 2, 3, 4], fn(x: int) -> int { return x * x }))
```

### 5.7 函數回傳型別與多值
- **多值回傳**：使用 tuple 同時返回多個值，例如 `(int, int)`。
  ```rust
  fn divide_and_remainder(a: int, b: int) -> (int, int) {
      quotient := a / b
      remainder := a % b
      return (quotient, remainder)
  }
  q, r := divide_and_remainder(10, 3)
  println(`商: ${q}, 餘數: ${r}`)
  ```
- **錯誤處理與替代型別**：使用 union 表示回傳結果可能是成功型別 T 或錯誤型別 error，例如：
  ```rust
  fn try_parse_division(s: string) -> union<(int, string), error> {
      if s == "42" { return (42, "成功") }
      else { return error("無法解析") }
  }
  result := try_parse_division("123")
  if is_error(result) { println("解析錯誤") }
  else { println(`成功: ${result}`) }
  ```
  為保持與 tuple 回傳寫法一致，建議使用括號明確表示，如 union<(int, string), error>。  
  內置函式 **is_error()** 用於快速檢查 union<T, error> 的錯誤狀態，正常情況下 union 值可直接當作 T 使用。

---

## 6. 併發機制

- 使用 `spawn fn` 啟動輕量執行緒，類似 Goroutine。
- 併發任務不會隱式等待，需使用 `await` 顯式同步。
- `await` 可同時等待多個任務（類似 Promise.all()）。

#### 範例
```rust
spawn fn work1() {
    println("工作 1 開始")
    sleep(1)
    println("工作 1 結束")
}
spawn fn work2() {
    println("工作 2 開始")
    sleep(2)
    println("工作 2 結束")
}
await work1(), work2()
println("所有工作結束")
```

---

## 7. `await` 回傳值規範

### 7.1 單一 `await`
- 等待單一函式完成並回傳結果。

#### 範例
```rust
spawn fn get_data() -> int {
    sleep(1)
    return 42
}
result := await get_data()
println(`結果: ${result}`)
```

### 7.2 多個 `await`
- 同時等待多個函式，回傳一個 tuple，順序與函式呼叫一致。

#### 範例
```rust
spawn fn task1() -> string {
    sleep(1)
    return "A"
}
spawn fn task2() -> string {
    sleep(2)
    return "B"
}
results := await task1(), task2()
println(`結果: ${results}`)
```

### 7.3 內建錯誤處理
- 若某函式發生錯誤，回傳 `error<T>`（類似 Rust 的 `Result<T, E>`）；可選使用 `try` 捕獲錯誤。

#### 範例
```rust
spawn fn fail_task() -> int {
    sleep(1)
    return error("任務失敗")
}
result := await fail_task()
if result is error {
    println(`錯誤: ${result}`)
} else {
    println(`成功: ${result}`)
}
```

### 7.4 用於迴圈
- 使用 `for` 迭代 `await` 回傳的結果（tuple）。

#### 範例
```rust
tasks := [task1(), task2(), task3()]
for result in await tasks {
    println(`結果: ${result}`)
}
```
**解析：**
- `await tasks` 同時等待所有函式執行完畢。
- `for result in await tasks` 逐一處理每個結果。

---

## 8. 參數傳遞語意

- **值傳遞**：基本型別（如 int、float、bool）預設值傳遞（記憶體小、複製成本低）。
- **引用傳遞**：複合型別（如 string、list、array、map、tuple、struct 等）預設引用傳遞，僅傳遞物件的引用，節省記憶體與提高效能。
- 若有特殊需求，可透過顯式語法指定傳遞方式。

---

## 9. 結構體與介面

### 9.1 Struct 結構體
- 使用 `struct` 宣告結構體。  
- 成員首字母大寫表示公開，首字母小寫表示私有。

#### 範例
```rust
struct User {
    Name: string,  // 公開
    age: int,      // 私有
}
```

### 9.2 Interface 介面
- 使用 `interface` 宣告介面，定義一組方法簽名。  
- 任何型別只要實作這些方法，即隱式實作該介面，無需額外聲明。

#### 範例
```rust
interface Reader {
    read() -> string
}
struct FileReader {
    fileName: string,
}
fn (fr FileReader) read() -> string {
    // 實作讀取檔案邏輯
    return "檔案內容"
}
fn printReader(r Reader) {
    println(r.read())
}
fileReader := FileReader{"data.txt"}
printReader(fileReader)
```

---

## 10. 內置函式：copy() 與 error()

- **copy()**：對集合、結構體或其他複合型別進行深拷貝，返回一個新物件，不共享記憶體。

  ```rust
  originalList := [1, 2, 3]
  copiedList := copy(originalList)
  copiedList.append(4)
  println(originalList)  // 輸出 [1, 2, 3]
  println(copiedList)    // 輸出 [1, 2, 3, 4]
  ```

- **error()**：生成一個 error 型別的錯誤物件，通常接受錯誤訊息字串作為參數，用於錯誤處理。

  ```rust
  fn try_parse_int(s: string) -> union<int, error> {
      if s == "42" { return 42 }
      else { return error("無法解析為整數") }
  }
  ```

---

## 11. 指標操作

- 使用 `&` 取得變數指標，使用 `*` 解參考。例如：
  ```rust
  x := 10
  p := &x  // p 為 ptr<int>
  println(*p)  // 輸出 10
  ```
- **注意：** 所有指標運算（如 `+`、`-`、`<<`、`>>` 等）必須在 `unsafe { }` 區塊中執行。
- 當使用點運算子（`.`）存取 struct、array、list、tuple 成員時，若成員為指標，Glux 會自動解參考，無需手動使用 `*`。

---

## 12. 運算符定義

### 算術運算符
- **`+`**：加法或字串串接。
- **`-`**：減法。
- **`*`**：乘法。
- **`/`**：除法。
- **`%`**：取餘。

### 比較運算符
- **`==`**、**`!=`**、**`<`**、**`<=`**、**`>`**、**`>=`**：檢查相等或大小關係。

### 邏輯運算符
- **`and`** 或 **`&&`**：邏輯與。
- **`or`** 或 **`||`**：邏輯或。
- **`not`** 或 **`!`**：邏輯非。

### 位元運算符
- **`&`**、**`|`**、**`^`**、**`~`**：分別用於位元與、或、異或、取反。  
  - 取地址時，`&` 用於取得變數指標。

### 位移運算符
- **`<<`**、**`>>`**：分別用於左移與右移。  
  - 注意：必須在 `unsafe { }` 區塊中執行。

### 賦值運算符
- **`:=`**：宣告並初始化變數。
- **`=`**：對已宣告變數賦值。
- 複合賦值：例如 **`+=`**、**`-=`**、**`*=`** 等。

### 其他運算符
- **`.`**：點運算子，用於存取結構體或複合型別成員，會自動解指標。
- **`,`**：逗號，用於分隔參數、tuple 成員等。

---

## 13. 強制類型轉換

Glux 提供以下內置函式進行顯式型別轉換：
- **int()**：轉換為 int。
- **float()**：轉換為 float。
- **bool()**：轉換為 bool。

例如：
```rust
s := "123"
n := int(s)
f := float("3.14")
b := bool(1)
```

---

## 14. 語言特性總結

✅ **簡單直覺，語法比 Go / Rust 更簡潔**  
✅ **支援 `0 < x < 8` 連續比較運算**  
✅ **`print()` 與 `println()` 分離，符合直覺**  
✅ **併發比 Go 更靈活，允許 `await` 多個任務**  
✅ **比 C / Go 更節省記憶體（數值型別自動擴展至 int64/float64，預設使用最小型別）**  
✅ **集合型別支援異質性，不需指定內部元素型別（如 list 而非 list<int>）**  
✅ **值與引用傳遞依據型別特性，自動選擇最合適的傳遞方式**  
✅ **內置 copy() 支援深拷貝**  
✅ **支援 struct 與 interface，實現隱式介面實作**  
✅ **函數回傳型別可利用 tuple 與 union 進行多值回傳與錯誤處理**  
   - 使用 tuple 表示同時返回多個值（例如 `(int, int)`）。
   - 使用 union 表示回傳結果可能是成功型別 T 或錯誤型別 error（例如 `union<(int, string), error>`），並保持與單獨 tuple 回傳寫法一致。
   - 內置函式 **is_error()** 用於快速檢查 union<T, error> 的錯誤狀態，正常情況下可直接使用。
✅ **內置 error 型別與 error() 函式用於錯誤處理**  
✅ **指標操作在任何地方可取指與解參考，但所有指標運算必須在 unsafe 區塊中進行；點運算子會自動解指標**  
✅ **內置強制類型轉換函式 int()、float()、bool() 提供顯式型別轉換**  
✅ **比 Python 更快，比 Go 更靈活，比 Rust 更易學**

這是一門 **高效能、易學、支援併發** 的語言，適用於系統開發、後端服務、資料處理等領域。 🚀