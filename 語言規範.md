# Glux 語言設計規範

Glux 是一門 **簡單、高效、省記憶體、支援併發、可編譯為二進制** 的靜態類型語言，擁有直覺的語法，結合了 Python、Go、Rust 的優勢。

---

## 1. 語法規範

### 1.1 變數與常數
- 變數使用 `:=` 進行宣告，類似 Go 的簡潔語法，支援型別推導。
- 常數使用 `const`，允許在編譯時或執行時決定數值。
- **支援連續比較運算**（如 `0 < x < 8`），語意等同於 `0 < x && x < 8`。

#### 範例
```rust
x := 10         // 自動推導為 int，根據數值大小選擇能容納該數值的最小型別
y := 3.14       // 自動推導為 float，同樣選擇最小精度型別
name := "Alice" // string
const PI = 3.1415  // 常數
```

---

### 1.2 型別系統

- **自動調整數值型別**  
  Glux 會根據整數或浮點數的數值範圍，自動選擇**能容納該數值的最小型別**。
  
  #### 整數 (int)
  - **int8**：範圍 -128 ~ 127  
    例：`x := 10`（若數值落在 int8 範圍內）
  - **int16**：範圍 -32,768 ~ 32,767  
    例：`y := 30000`（自動推導為 int16）
  - **int32**：範圍 -2,147,483,648 ~ 2,147,483,647  
    例：`z := 2_000_000_000`（自動推導為 int32）
  - **int64**：範圍 -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807  
    若數值超出 int32 範圍且在 int64 內，則自動推導為 int64.
  
  #### 浮點數 (float)
  - **float32**：32 位 IEEE 754 浮點數，精度約 7 位有效數字  
    當數值適中且精度要求不高時，採用 float32.
  - **float64**：64 位 IEEE 754 浮點數，精度約 15 位有效數字  
    當數值較大或需要更高精度時，自動推導為 float64.
  
- **內置錯誤型別 error**  
  Glux 內置錯誤型別 **error**，用於表示錯誤狀態與錯誤訊息，通常與 union 搭配使用實現錯誤處理。
  
- **集合型別支援異質性**  
  集合型別（如 tuple、list、array、map）不需要指定內部元素型別，允許同時存放不同型別的值。例如：
  ```rust
  mixedList := [10, "hello", 3.14]  // list 可包含不同型別
  ```
- **內建函式 `string()`**  
  可轉換任何型別為字串（此為內置函式之一，與 `sleep()`、`len()` 同級）。

#### 範例
```rust
x := 10         // 推導為 int8 (若數值符合 int8 範圍)
y := 30000      // 推導為 int16
z := 2_000_000_000  // 推導為 int32
bigNum := 10_000_000_000  // 超出 int32，自動推導為 int64

pi32 := 3.14    // 推導為 float32
largeFloat := 3.141592653589793  // 推導為 float64
```

附上型別系統的總結表：

| 分類         | 型別         | 說明                                                     |
|--------------|--------------|----------------------------------------------------------|
| **基本型別**   | 整數         | `int`（自動調整至 int8、int16、int32、int64；預設使用最小型別）       |
|              | 浮點數       | `float`（自動調整至 float32 或 float64；預設使用最小型別）             |
|              | 布林值       | `bool`                                                 |
|              | 字串         | `string`                                               |
|              | 任意型別     | `any`                                                  |
|              | 錯誤         | `error`（內置錯誤型別，用於表示錯誤狀態與訊息）                     |
| **集合型別**   | 元組         | `tuple`（值不能更改）                                                |
|              | 清單         | `list`                                                 |
|              | 陣列         | `array`                                                |
|              | 映射         | `map`                                                  |
| **函式型別**   | 函式         | `fn<T>`                                                |
| **進階型別**   | 多選型別     | `union<T1, T2>`                                        |
|              | 指標         | `ptr<T>`                                               |
|              | 選用型別     | `optional<T>`                                          |

---

### 1.3 控制流程
- `if`、`while` 條件表達式無需括號 `()`。
- **支援連續比較運算**（如 `0 < x < 8`），提高可讀性。
- `for` 使用 `range()` 迭代，不支援傳統 `for (init; condition; update)`。

#### 範例
```rust
if 0 < x < 8 {
    println("x 在範圍內")
}

while x < 100 {
    x *= 2
}

for i in range(5) {
    println(i)  // 輸出 0, 1, 2, 3, 4
}

for key, value in {"a": 1, "b": 2} {
    println(`${key}: ${value}`)
}
```

---

## 2. 運算符

✅ **`and`、`or`、`not` 可用關鍵字或符號**  
✅ **比 Go 更靈活（Go 只有 `&&`、`||`、`!`）**

#### 範例
```rust
if x > 0 and y < 10 {
    print("範圍內")
}

if x > 0 && y < 10 {
    print("範圍內")
}

flag := not x
flag2 := !x
```

---

## 3. 標準函式

### 3.1 內置函式
內置函式包含常用的工具，例如：
- **string()**：將任何型別轉換為字串，方便輸出與除錯。
- **sleep()**：暫停執行，用於併發與計時操作。
- **len()**：計算集合型別（如 list、array、map、tuple）或字串的長度。
- **copy()**：對集合型別、結構體或其他複合型別進行深拷貝，返回一個與原物件不共享記憶體的新物件。
- **error()**：生成一個 error 型別的錯誤物件，通常接受一個錯誤訊息字串作為參數。

### 3.2 `print()` 與 `println()`
- **`print()`**：輸出字串但不換行。
- **`println()`**：輸出字串並自動換行。
- **支援 `${}` 字串插值**，比 Go 的 `fmt.Sprintf()` 更簡潔。
- **使用 \`（反引號）支援插值**，使用 `"` 會當作純字串處理。

#### 範例
```rust
name := "Alice"
age := 25
print(`Hello, ${name}. You are ${age} years old.`)  // 不換行
println(`你的年齡是 ${age}.`)  // 換行輸出

nums := [1, 2, 3]
println("List:", nums)  // 輸出 "[1, 2, 3]"
```

#### 3.3 字串處理
- **字串串接**：使用 `+` 運算子串接多個字串。  
  **範例：**
  ```rust
  greeting := "Hello, " + "World!"
  println(greeting)  // 輸出 "Hello, World!"
  ```
- **多行字串**：使用反引號 `` ` `` 定義多行字串，保留換行與空白。  
  **範例：**
  ```rust
  poem := `這是一首詩，
  可以跨多行，
  每行的空白都會被保留。`
  println(poem)
  ```

---

## 4. 可見性

✅ **首字母大寫公開，小寫私有**（與 Go 相同，避免使用 `public` / `private` 關鍵字）

#### 範例
```rust
struct User {
    Name: string,  // 公開
    age: int,      // 私有
}
```

---

## 5. 函式與閉包
Glux 支援 **函式（Function）**、**匿名函式（Lambda）** 以及 **閉包（Closure）**，並提供靜態語言的高效與靈活性，使函式成為 **一級公民（First-Class Citizen）**。

### 5.1 基本函式語法
- 使用 `fn` 宣告函式，回傳型別使用 `->` 指定。
- 可選回傳型別，若省略則根據 `return` 自動推導。
- 支援預設參數，允許部分參數有預設值。
- 函式可作為變數、參數與回傳值。

#### 範例
```rust
fn add(x: int, y: int) -> int {
    return x + y
}

println(add(2, 3))  // 輸出 5
```

---

### 5.2 匿名函式（Lambda）
- 使用 `fn` 宣告匿名函式，並可直接賦值給變數。
- 可作為參數傳遞至其他函式。

#### 範例
```rust
double := fn(x: int) -> int {
    return x * 2
}

println(double(10))  // 輸出 20
```

**作為參數傳遞**
```rust
fn apply_twice(f: fn(int) -> int, x: int) -> int {
    return f(f(x))
}

println(apply_twice(fn(x: int) -> int {
    return x + 3
}, 5))  // 輸出 11
```

---

### 5.3 閉包（Closure）
- 閉包可捕獲外部變數，形成閉包。
- 允許讀取與修改外部變數（類似 Rust）。

#### 範例
```rust
fn make_multiplier(factor: int) -> fn(int) -> int {
    return fn(x: int) -> int {
        return x * factor
    }
}

double := make_multiplier(2)
triple := make_multiplier(3)

println(double(5))  // 輸出 10
println(triple(5))  // 輸出 15
```

---

### 5.4 函式作為回傳值
- 函式可作為回傳值，允許動態生成新函式。

#### 範例
```rust
fn choose_operation(op: string) -> fn(int, int) -> int {
    if op == "add" {
        return fn(a: int, b: int) -> int {
            return a + b
        }
    } else {
        return fn(a: int, b: int) -> int {
            return a - b
        }
    }
}

op := choose_operation("add")
println(op(3, 5))  // 輸出 8
```

---

### 5.5 變數捕獲（Capturing）
- 閉包可讀取與修改外部變數。
- 若閉包在函式返回後仍存活，則捕獲的變數將存於堆區。

#### 範例
```rust
fn counter() -> fn() -> int {
    count := 0
    return fn() -> int {
        count += 1
        return count
    }
}

next := counter()
println(next())  // 輸出 1
println(next())  // 輸出 2
```

---

### 5.6 高階函式（Higher-Order Function）
- 支援函式作為參數，方便實現高階函式。

#### 範例
```rust
fn map(lst: list, f: fn(int) -> int) -> list {
    result := []
    for x in lst {
        result.append(f(x))
    }
    return result
}

println(map([1, 2, 3, 4], fn(x: int) -> int {
    return x * x
}))  // 輸出 [1, 4, 9, 16]
```

---

### 5.7 函數回傳型別與多值
- **多值回傳**：函數可透過 tuple 同時返回多個值，所有回傳值均存在於一個 tuple 中。例如：
  ```rust
  fn divide_and_remainder(a: int, b: int) -> (int, int) {
      quotient := a / b
      remainder := a % b
      return (quotient, remainder)
  }
  
  q, r := divide_and_remainder(10, 3)
  println(`商: ${q}, 餘數: ${r}`)  // 輸出 "商: 3, 餘數: 1"
  ```
  
- **錯誤處理與替代型別**：若函數回傳結果可能屬於成功型別 T 或錯誤型別 E（此處錯誤型別為內置 error），則可使用 union<T, error> 表示。例如，若要回傳多個值且可能出錯，可定義如下：
  ```rust
  fn try_parse_division(s: string) -> union<(int, string), error> {
      // 回傳一個 tuple，第一個元素為 int，第二個元素為 string
      if s == "42" {
          return (42, "成功")
      } else {
          return error("無法解析")
      }
  }
  ```
  
  為了簡化錯誤檢查，Glux 提供內置函式 **is_error()**。使用者可直接利用 is_error() 快速判斷函數是否發生錯誤；當結果非錯誤時，union 值可直接視為 T 使用，無需額外 unwrap()。
  
  **範例：**
  ```rust
  result := try_parse_int("123")  // 定義為 union<int, error>
  if is_error(result) {
      println("解析錯誤")
  } else {
      println(`成功解析: ${result}`)  // 直接使用 result 作為 int
  }
  ```
  
  為保持與單獨 tuple 回傳寫法一致，若明確指定 tuple 型別，建議使用括號表示，如 union<(int, string), error>。

---

## 6. 併發機制
- 使用 `spawn fn` 啟動輕量執行緒，類似 Goroutine。
- 併發任務不會隱式等待，需使用 `await` 顯式同步。
- `await` 可同時等待多個任務，類似 `Promise.all()`。

#### 範例
```rust
spawn fn work1() {
    println("工作 1 開始")
    sleep(1)
    println("工作 1 結束")
}

spawn fn work2() {
    println("工作 2 開始")
    sleep(2)
    println("工作 2 結束")
}

await work1(), work2()  // 等待最慢的任務完成
println("所有工作結束")
```

---

## 7. `await` 回傳值規範
### 7.1 單一 `await`
當 `await` 用於單一函式時，會等待其執行完成，並回傳該函式的結果。

#### 範例
```rust
spawn fn get_data() -> int {
    sleep(1)
    return 42
}

result := await get_data()
println(`結果: ${result}`)  // 輸出 "結果: 42"
```

---

### 7.2 `await` 多個函式
當 `await` 用於多個函式時，回傳一個 tuple，且結果順序與函式順序相同。

#### 範例
```rust
spawn fn task1() -> string {
    sleep(1)
    return "A"
}

spawn fn task2() -> string {
    sleep(2)
    return "B"
}

results := await task1(), task2()
println(`結果: ${results}`)  // 輸出 "結果: ("A", "B")"
```

---

### 7.3 `await` 內建錯誤處理
若 `await` 中的某個函式發生錯誤：
- **預設行為**：回傳 `error<T>` 類型（類似 Rust 的 `Result<T, E>`）。
- **可選行為**：可使用 `try` 捕獲錯誤。

#### 範例
```rust
spawn fn fail_task() -> int {
    sleep(1)
    return error("任務失敗")
}

result := await fail_task()
if result is error {
    println(`錯誤: ${result}`)
} else {
    println(`成功: ${result}`)
}
```

---

### 7.4 `await` 用於迴圈
當有多個併發函式需要逐一處理時，可使用 `for` 迭代 `await` 結果：

#### 範例
```rust
tasks := [task1(), task2(), task3()]

for result in await tasks {
    println(`結果: ${result}`)
}
```
**行為解析**：
- `await tasks` 同時等待所有函式執行完畢。
- `for result in await tasks` 逐一處理每個結果。

---

## 8. 參數傳遞語意

- **值傳遞**：對於基本型別（如 int、float、bool），預設採用值傳遞，因其佔用記憶體小且複製成本低。
- **引用傳遞**：對於複合型別（如 string、list、array、map、tuple、struct 等），預設採用引用傳遞，以節省記憶體與提高效能；在函式呼叫中，傳遞的是物件的引用，而非整個複製品。
- 若有需要，也可透過顯式語法指定使用值傳遞或引用傳遞，以滿足特殊需求。

---

## 9. 結構體與介面

### 9.1 Struct 結構體
- 使用 `struct` 關鍵字宣告結構體。  
- 結構體成員中，首字母大寫表示公開，首字母小寫表示私有，與 Go 的規範相同。

#### 範例
```rust
struct User {
    Name: string,  // 公開
    age: int,      // 私有
}
```

### 9.2 Interface 介面
- 使用 `interface` 關鍵字宣告介面，定義一組方法簽名。  
- 任何型別只要實作這些方法，即隱式實作該介面，無需額外聲明。

#### 範例
```rust
interface Reader {
    read() -> string
}

struct FileReader {
    fileName: string,
}

fn (fr FileReader) read() -> string {
    // 實作讀取檔案的邏輯
    return "檔案內容"
}

fn printReader(r Reader) {
    println(r.read())
}

fileReader := FileReader{"data.txt"}
printReader(fileReader)  // 輸出 "檔案內容"
```

---

## 10. 內置函式：copy() 與 error()

- **copy()**：提供一個內置函式，用於對集合型別、結構體或其他複合型別進行深拷貝，返回一個與原物件不共享記憶體的新物件。

  **範例：**
  ```rust
  originalList := [1, 2, 3]
  copiedList := copy(originalList)
  copiedList.append(4)
  println(originalList)  // 輸出 [1, 2, 3]
  println(copiedList)    // 輸出 [1, 2, 3, 4]
  ```

- **error()**：內置函式，用於生成一個 error 型別的錯誤物件，通常接受一個錯誤訊息字串作為參數。

  **範例：**
  ```rust
  fn try_parse_int(s: string) -> union<int, error> {
      if s == "42" {
          return 42
      } else {
          return error("無法解析為整數")
      }
  }
  ```

---

## 11. 指標操作

- Glux 支援在任何地方使用 `&` 取得變數的指標，並使用 `*` 解參考以取得指向的值。例如：
  ```rust
  x := 10
  p := &x  // p 的型別為 ptr<int>
  println(*p)  // 輸出 10
  ```
- **注意：** 所有指標運算（如 `+`、`-`、`<<`、`>>` 等）只能在 `unsafe { }` 區塊中進行，以確保安全性。
- 當使用點運算子（`.`）存取 struct、array、list、tuple 等複合型別成員時，如果該成員為指標，Glux 會自動解參考，無需手動使用 `*`。

---

## 12. 語言特性總結
✅ **簡單直覺，語法比 Go / Rust 更簡潔**  
✅ **支援 `0 < x < 8` 連續比較運算**  
✅ **`print()` 與 `println()` 分離，符合直覺**  
✅ **併發比 Go 更靈活，允許 `await` 多個任務**  
✅ **比 C / Go 更節省記憶體（數值型別自動擴展至 int64/float64，預設使用最小型別）**  
✅ **集合型別支援異質性，不需指定內部元素型別（如 `list` 而非 `list<int>`）**  
✅ **值與引用傳遞依據型別特性，自動選擇最合適的傳遞方式**  
✅ **內置 copy() 支援深拷貝**  
✅ **支援 struct 與 interface，實現隱式介面實作**  
✅ **函數回傳型別可利用 tuple 與 union 進行多值回傳與錯誤處理**  
   - 使用 tuple 表示同時返回多個值（例如 `(int, int)`）。
   - 使用 union 表示回傳結果可能是成功型別 T 或錯誤型別 error（例如 `union<(int, string), error>`），並保持與單獨 tuple 回傳寫法一致。
   - 內置函式 **is_error()** 用於快速檢查 union<T, error> 的錯誤狀態，當結果正常時可直接使用。
✅ **內置 error 型別與 error() 函式用於錯誤處理**  
✅ **指標操作在任何地方可取指與解參考，但所有指標運算必須在 unsafe 區塊中進行；點運算子會自動解指標**  
✅ **比 Python 更快，比 Go 更靈活，比 Rust 更易學**

這是一門 **高效能、易學、支援併發** 的語言，適用於系統開發、後端服務、資料處理等領域。 🚀
